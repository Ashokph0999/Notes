{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang2057{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset2 Symbol;}}
{\colortbl ;\red0\green255\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green0\blue255;\red0\green255\blue0;\red0\green77\blue187;\red192\green80\blue77;\red75\green172\blue198;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\highlight1\b\f0\fs32\lang9 Golang\par
\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\cf2\highlight0\b0\fs22 What is Go : \cf0\par

\pard\sa200\sl276\slmult1 1.cross-platform, open source\par
2.create high-performance applications.\par
3.fast, statically typed, compiled language that feels like a dynamically typed, interpreted language\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\cf2 Used : \cf0\par

\pard\sa200\sl276\slmult1 1.Web development (server-side)\par
2.Developing network-based programs\par
3.Developing cross-platform enterprise applications\par
4.Cloud-native development\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\cf2 Syntax of print statement: \cf0\par

\pard\sa200\sl276\slmult1\highlight3 Example: \highlight0\par
package main\par
import ("fmt")\par
func main() \{\par
  fmt.Println("Hello World!")\par
\}\par
\highlight4 output\highlight0  : Hello World!\par
\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\highlight5 Go Variables\highlight0\par

\pard\sa200\sl276\slmult1 Variables are containers for storing data values.\par
\highlight3 Syntax\par
\highlight0 1.With the var keyword:\par
\cf6 var variablename type = value\cf0\par
2.With the := sign\par
\cf6 variablename := value\par
\cf0 Note:  It is not possible to declare a variable using :=, without assigning a value to it.\par
\highlight3 Example \par
\highlight0\par
\highlight1 Eg 1. Variable Declaration With Initial Value\highlight0\par
\cf7 package main\par
import ("fmt")\par
func main() \{\par
  var student1 string = "Ashok" //type is string\par
  var student2 = "Patil" //type is inferred\par
  x := 9 //type is inferred\par
   fmt.Println(student1)\par
  fmt.Println(student2)\par
  fmt.Println(x)\par
\}\par
\cf0\highlight3 Output :\highlight0\par
Ashok\par
Patil\par
9\par
\highlight1 Eg 2. Variable Declaration Without Initial Value\par
\cf7\highlight0 package main\par
import ("fmt")\par
func main() \{\par
  var a string\par
  var b int\par
  var c bool\par
  fmt.Println(a)\par
  fmt.Println(b)\par
  fmt.Println(c)\par
\}\par
\cf0\highlight3 Output : \highlight0\par
0\par
false\par
\highlight1 Eg 3. Value Assignment After Declaration\par
\cf7\highlight0 package main\par
import ("fmt")\par
   func main() \{\par
  var student1 string\par
  student1 = "Ashok"\par
  fmt.Println(student1)\par
\}\par
\cf0\highlight3 Output : \highlight0  Ashok.\par
\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\highlight5 Go Constants\highlight0\par

\pard\sa200\sl276\slmult1  If a variable should have a fixed value that cannot be changed, you can use the const keyword.\cf7\par
\cf0 The const keyword declares the variable as "constant", which means that it is unchangeable and read-only.\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\cf2 Constant rules :\cf0\par

\pard\sa200\sl276\slmult1 1.Constant names follow the same naming rules as variables\par
2.Constant names are usually written in uppercase letters (for easy identification and differentiation from variables).\par
3.Constants can be declared both inside and outside of a function.\par
\cf2 1.Declaring a Constant \cf0 : \par
\highlight3 eg.\highlight0\par
package main\par
import ("fmt")\par
const PI = 3.14\par
 func main() \{\par
  fmt.Println(PI)\par
\}\par
\highlight3 output :\highlight0  3.14\par
\par
\cf2 2.Constant Types : \cf0\par
a) Typed constants : Typed constants are declared with a defined type\par
eg.\par
package main\par
import ("fmt")\par
const A \cf2 int \cf0 = 1\par
 func main() \{\par
  fmt.Println(A)\par
\}\par
\highlight3 output : \highlight0  1\par
\par
b) Untyped constants : Untyped constants are declared without a type.\par
eg.\par
package main\par
import ("fmt")\par
const A = 1\par
func main() \{\par
  fmt.Println(A)\par
\}\par
\highlight3 output \highlight0  :1\par
\par
3.\cf2 Multiple Constants Declaration : \cf0 Multiple constants can be grouped together into a block for readability.\par
Eg.\par
package main\par
import ("fmt")\par
const (\par
  A int = 1\par
  B = 3.14\par
  C = "Hi!"\par
)\par
func main() \{\par
  fmt.Println(A)\par
  fmt.Println(B)\par
  fmt.Println(C)\par
\}\par
\highlight3 output \highlight0  : \par
1\par
3.14\par
Hi!\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\highlight5 Go Output Functions\highlight0\par

\pard\sa200\sl276\slmult1\par
\cf2 1.Print() :\par
\cf0 It is also possible to only use one Print() for printing multiple variables.\par
eg.\par
package main\par
import ("fmt")\par
 func main() \{\par
  var i, j string = "Hello","World"\par
  fmt.Print(i, "\\n", j)\par
\}\par
\highlight3 output \highlight0  : \par
Hello\par
World\par
\cf2 2.Println() : \par
\cf0 The Println() function is similar to Print() with the difference that a whitespace is added between the arguments, and a newline is added at the end.\par
eg.\par
package main\par
import ("fmt")\par
 func main() \{\par
 var i,j string = "Hello","World"\par
fmt.Println(i,j)\par
\}\par
\highlight3 output : \highlight0  Hello World\par
\par
\cf2 3.Printf() \cf0 : The Printf() function first formats its argument based on the given formatting verb and then prints them.\par
a) %v is used to print the value of the arguments\par
 b) %T is used to print the type of the arguments\par
Eg.\par
package main\par
import ("fmt")\par
func main() \{\par
  var i string = "Hello"\par
  var j int = 15\par
fmt.Printf("i has value: %v and type: %T\\n", i, i)\par
fmt.Printf("j has value: %v and type: %T", j, j)  \par
\}\par
\highlight3 output : \highlight0  \par
i has value: Hello and type: string\par
j has value: 15 and type: int\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\highlight5 Go Data Types\highlight0\par

\pard\sa200\sl276\slmult1\par
1.bool: represents a boolean value and is either true or false\par
2.Numeric: represents integer types, floating point values, and complex types\par
3.string: represents a string value\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\highlight5 Go Arrays\highlight0\par

\pard\sa200\sl276\slmult1 Arrays are used to store multiple values of the same type in a single variable, instead of declaring separate variables for each value.\par
\highlight3 eg.\par
\highlight0 package main\par
import ("fmt")\par
func main() \{\par
  var arr1 = [3]int\{1,2,3\}   // With the var keyword\par
  arr2 := [5]int\{4,5,6,7,8\} // With the := sign:\par
  fmt.Println(arr1)\par
  fmt.Println(arr2)\par
\}\par
\highlight3 output : \highlight0  \par
[1 2 3]\par
[4 5 6 7 8]\par
\cf2 1.Access Elements of an Array\par
\cf0 You can access a specific array element by referring to the index number.\par
\highlight3 eg.\highlight0\par
package main\par
import ("fmt")\par
func main() \{\par
  prices := [3]int\{10,20,30\}\par
 fmt.Println(prices[0])\par
  fmt.Println(prices[2])\par
\}\par
\highlight3 output : \highlight0   \par
10\par
30\cf2\par
2.Change Elements of an Array\par
\cf0 You can also change the value of a specific array element by referring to the index number.\par
\highlight3 eg.\highlight0\par
package main\par
import ("fmt")\par
func main() \{\par
  prices := [3]int\{10,20,30\}\par
  prices[2] = 50\par
  fmt.Println(prices)\par
\}\par
\highlight3 output : \highlight0   [10 20 50]\par
\par
\cf2 3.Array Initialization\par
\cf0 If an array or one of its elements has not been initialized in the code, it is assigned the default value of its type.\par
The default value for int is 0, and the default value for string is "".\par
\highlight3 eg.\highlight0\par
package main\par
import ("fmt")\par
func main() \{\par
  arr1 := [5]int\{\} //not initialized\par
  arr2 := [5]int\{1,2\} //partially initialized\par
  arr3 := [5]int\{1,2,3,4,5\} //fully initialized\par
 fmt.Println(arr1)\par
  fmt.Println(arr2)\par
  fmt.Println(arr3)\par
\}\par
\highlight3 output : \highlight0   \par
[0 0 0 0 0]\par
[1 2 0 0 0]\par
[1 2 3 4 5]\par
\cf2 4.Initialize Only Specific Elements\par
\cf0 It is possible to initialize only specific elements in an array.\par
\highlight3 eg.\highlight0\par
package main\par
import ("fmt")\par
func main() \{\par
  arr1 := [5]int\{1:10,2:40\}\par
fmt.Println(arr1)\par
\}\par
\highlight3 output : \highlight0   [0 10 40 0 0]\par
1:10 means: assign 10 to array index 1 (second element).\par
2:40 means: assign 40 to array index 2 (third element).\par
\cf2 5.Find the Length of an Array\par
\cf0 The len() function is used to find the length of an array\par
\highlight3 eg\highlight0\par
package main\par
import ("fmt")\par
func main() \{\par
  arr1 := [4]string\{"Volvo", "BMW", "Ford", "Mazda"\}\par
  arr2 := [...]int\{1,2,3,4,5,6\}\par
  fmt.Println(len(arr1))\par
  fmt.Println(len(arr2))\par
\}\par
\highlight3 output : \highlight0   \par
4\par
6\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\highlight1 Go Slices\highlight0\par

\pard\sa200\sl276\slmult1 Slices are similar to arrays, but are more powerful and flexible.\par
a.Like arrays, slices are also used to store multiple values of the same type in a single variable.\par
b.However, unlike arrays, the length of a slice can grow and shrink as you see fit.\par
c.In Go, there are several ways to create a slice:\par
d.Using the []datatype\{values\} format\par
e.Create a slice from an array\par
f.Using the make() function\par
\cf2 1.Create a Slice With []datatype\{values\}\par
\cf0 a.len() function - returns the length of the slice (the number of elements in the slice)\par
b.cap() function - returns the capacity of the slice(the number of elements the slice can grow or shrink to)\par
\highlight3 eg.\par
\highlight0 package main\par
import ("fmt")\par
func main() \{\par
  myslice1 := []int\{\}\par
  fmt.Println(len(myslice1))\par
  fmt.Println(cap(myslice1))\par
  fmt.Println(myslice1)\par
   myslice2 := []string\{"Go", "Slices", "Are", "Powerful"\}\par
  fmt.Println(len(myslice2))\par
  fmt.Println(cap(myslice2))\par
  fmt.Println(myslice2)\par
\}\par
\highlight3 Output : \highlight0   \par
0\par
0\par
[]\par
4\par
4\par
[Go Slices Are Powerful]\par
\cf2 2.Create a Slice From an Array\cf0\par
\highlight3 Syntax :\highlight0  \par
var myarray = [length]datatype\{values\} // An array\par
myslice := myarray[start:end] // A slice made from the array\par
\highlight3 Eg.\highlight0\par
package main\par
import ("fmt")\par
func main() \{\par
  arr1 := [6]int\{10, 11, 12, 13, 14,15\}\par
  myslice := arr1[2:4]\par
 fmt.Printf("myslice = %v\\n", myslice)\par
  fmt.Printf("length = %d\\n", len(myslice))\par
  fmt.Printf("capacity = %d\\n", cap(myslice))\par
\}\par
\highlight3 output :\highlight0\par
myslice = [12 13]\par
length = 2\par
capacity = 4\par
\cf2 3.Create a Slice With The make() Function\cf0\par
\highlight3 Syntax :\highlight0  slice_name := make([]type, length, capacity)\par
\cf8 Note: If the capacity parameter is not defined, it will be equal to length.\par
\cf0\highlight3 Eg.\highlight0\par
package main\par
import ("fmt")\par
func main() \{\par
  myslice1 := make([]int, 5, 10)\par
  fmt.Printf("myslice1 = %v\\n", myslice1)\par
  fmt.Printf("length = %d\\n", len(myslice1))\par
  fmt.Printf("capacity = %d\\n", cap(myslice1))\par
 // with omitted capacity\par
  myslice2 := make([]int, 5)\par
  fmt.Printf("myslice2 = %v\\n", myslice2)\par
  fmt.Printf("length = %d\\n", len(myslice2))\par
  fmt.Printf("capacity = %d\\n", cap(myslice2))\par
\}\par
\highlight3 Output : \highlight0  \par
myslice1 = [0 0 0 0 0]\par
length = 5\par
capacity = 10\par
myslice2 = [0 0 0 0 0]\par
length = 5\par
capacity = 5\par
\cf2 4.Access Elements of a Slice\par
\cf0 You can access a specific slice element by referring to the index number.\par
In Go, indexes start at 0. That means that [0] is the first element, [1] is the second element, etc.\par
\highlight3 Example :\highlight0\par
package main\par
import ("fmt")\par
func main() \{\par
  prices := []int\{10,20,30\}\par
  fmt.Println(prices[0])\par
  fmt.Println(prices[2])\par
\}\par
\highlight3 Output : \highlight0  \par
10\par
30\par
\cf2 5.Change Elements of a Slice\par
\cf0 You can also change a specific slice element by referring to the index number.\par
\highlight3 Example :\par
\highlight0 package main\par
import ("fmt")\par
func main() \{\par
  prices := []int\{10,20,30\}\par
  prices[2] = 50\par
  fmt.Println(prices[0])\par
  fmt.Println(prices[2])\par
\}\highlight3\par
Output : \highlight0  \par
10\par
50\par
\cf2 6.Append Elements To a Slice\par
\cf0 You can append elements to the end of a slice using the append()function:\par
\highlight3 Syntax :\highlight0  slice_name = append(slice_name, element1, element2, ...)\par
\par
\highlight3 Example :\par
\highlight0 package main\par
import ("fmt")\par
func main() \{\par
  myslice1 := []int\{1, 2, 3, 4, 5, 6\}\par
  fmt.Printf("myslice1 = %v\\n", myslice1)\par
  fmt.Printf("length = %d\\n", len(myslice1))\par
  fmt.Printf("capacity = %d\\n", cap(myslice1))\par
  myslice1 = append(myslice1, 20, 21)\par
  fmt.Printf("myslice1 = %v\\n", myslice1)\par
  fmt.Printf("length = %d\\n", len(myslice1))\par
  fmt.Printf("capacity = %d\\n", cap(myslice1))\par
\}\highlight3\par
Output : \highlight0  \par
myslice1 = [1 2 3 4 5 6]\par
length = 6\par
capacity = 6\par
myslice1 = [1 2 3 4 5 6 20 21]\par
length = 8\par
capacity = 12\par
\cf2 7.Append One Slice To Another Slice\par
\cf0 To append all the elements of one slice to another slice, use the append()function:\cf2\par
\cf0\highlight3 Syntax : \highlight0  slice3 = append(slice1, slice2...)\highlight3\par
\par
Example :\par
\highlight0 package main\par
import ("fmt")\par
   func main() \{\par
  myslice1 := []int\{1,2,3\}\par
  myslice2 := []int\{4,5,6\}\par
  myslice3 := append(myslice1, myslice2...)\par
   fmt.Printf("myslice3=%v\\n", myslice3)\par
  fmt.Printf("length=%d\\n", len(myslice3))\par
  fmt.Printf("capacity=%d\\n", cap(myslice3))\par
\}\highlight3\par
Output : \highlight0  \highlight3\par
\highlight0 myslice3=[1 2 3 4 5 6]\par
length=6\par
capacity=6\par
\cf2 8.Change The Length of a Slice\cf0\par
it is possible to change the length of a slice.\par
\highlight3 Example :\par
\highlight0 package main\par
import ("fmt")\par
func main() \{\par
  arr1 := [6]int\{9, 10, 11, 12, 13, 14\} // An array\par
  myslice1 := arr1[1:5] // Slice array\par
  fmt.Printf("myslice1 = %v\\n", myslice1)\par
  fmt.Printf("length = %d\\n", len(myslice1))\par
  fmt.Printf("capacity = %d\\n", cap(myslice1))\par
  myslice1 = arr1[1:3] // Change length by re-slicing the array\par
  fmt.Printf("myslice1 = %v\\n", myslice1)\par
  fmt.Printf("length = %d\\n", len(myslice1))\par
  fmt.Printf("capacity = %d\\n", cap(myslice1))\par
  myslice1 = append(myslice1, 20, 21, 22, 23) // Change length by appending items\par
  fmt.Printf("myslice1 = %v\\n", myslice1)\par
  fmt.Printf("length = %d\\n", len(myslice1))\par
  fmt.Printf("capacity = %d\\n", cap(myslice1))\par
\}\highlight3\par
Output : \highlight0  \par
myslice1 = [10 11 12 13]\par
length = 4\par
capacity = 5\par
myslice1 = [10 11]\par
length = 2\par
capacity = 5\par
myslice1 = [10 11 20 21 22 23]\par
 \par
capacity = 10\par
\cf2 9.Memory Efficiency\par
\cf0 If the array is large and you need only a few elements, it is better to copy those elements using the copy() function.\par
\highlight3 Syntax:  \highlight0  copy(dest, src)\par
The copy() function takes in two slices dest and src, and copies data from src to dest. It returns the number of elements copied.\par
\highlight3 Example:\par
\highlight0 package main\par
import ("fmt")\par
func main() \{\par
  numbers := []int\{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15\}\par
  // Original slice\par
  fmt.Printf("numbers = %v\\n", numbers)\par
  fmt.Printf("length = %d\\n", len(numbers))\par
  fmt.Printf("capacity = %d\\n", cap(numbers))\par
  // Create copy with only needed numbers\par
  neededNumbers := numbers[:len(numbers)-10]\par
  numbersCopy := make([]int, len(neededNumbers))\par
  copy(numbersCopy, neededNumbers)\par
  fmt.Printf("numbersCopy = %v\\n", numbersCopy)\par
  fmt.Printf("length = %d\\n", len(numbersCopy))\par
  fmt.Printf("capacity = %d\\n", cap(numbersCopy))\par
\}\par
\highlight3 Output : \highlight0  \par
// Original slice\par
numbers = [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]\par
length = 15\par
capacity = 15\par
// New slice\par
numbersCopy = [1 2 3 4 5]\par
length = 5\par
capacity = 5\par
\highlight3\par
\par
\highlight0\par
\par
\highlight3\par
\par
\highlight0\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
  \par
\par
}
 